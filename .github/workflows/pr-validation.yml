# PR Validation Workflow
# Prevents PR failures by validating branch names, commits, and content

name: PR Validation

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  statuses: write

jobs:
  validate-branch:
    name: Validate Branch Name
    runs-on: ubuntu-latest
    outputs:
      is_agent_branch: ${{ steps.check.outputs.is_agent }}
      branch_valid: ${{ steps.check.outputs.valid }}
    steps:
      - name: Check Branch Name
        id: check
        run: |
          BRANCH="${{ github.head_ref }}"
          echo "Checking branch: $BRANCH"

          # Check if it's a claude agent branch
          if [[ "$BRANCH" =~ ^claude/ ]]; then
            echo "is_agent=true" >> $GITHUB_OUTPUT
            echo "Agent branch detected"

            # Validate agent branch format: claude/{type}-{description}-{id}
            if [[ "$BRANCH" =~ ^claude/(fix|feature|docs|refactor|test|setup|security)-.+-[a-zA-Z0-9]+$ ]]; then
              echo "valid=true" >> $GITHUB_OUTPUT
              echo "Branch name is valid"
            else
              echo "valid=false" >> $GITHUB_OUTPUT
              echo "::error::Invalid agent branch format. Expected: claude/{type}-{description}-{session-id}"
              exit 1
            fi
          else
            echo "is_agent=false" >> $GITHUB_OUTPUT
            echo "valid=true" >> $GITHUB_OUTPUT
            echo "Human branch - skipping strict validation"
          fi

  validate-commits:
    name: Validate Commit Messages
    runs-on: ubuntu-latest
    needs: validate-branch
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check Commit Messages
        run: |
          echo "Validating commit messages..."

          # Get commits in PR
          COMMITS=$(git log --oneline origin/${{ github.base_ref }}..HEAD)
          echo "Commits to validate:"
          echo "$COMMITS"

          # Valid commit types
          VALID_TYPES="feat|fix|docs|style|refactor|test|chore|security|perf|ci|build|revert"

          # Check each commit
          FAILED=0
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              # Extract message (skip hash)
              MSG=$(echo "$line" | cut -d' ' -f2-)

              # Check format: type: description or type(scope): description
              if [[ ! "$MSG" =~ ^($VALID_TYPES)(\(.+\))?:\ .+ ]]; then
                echo "::warning::Commit message doesn't follow convention: $MSG"
                # Only fail for agent branches
                if [[ "${{ needs.validate-branch.outputs.is_agent_branch }}" == "true" ]]; then
                  FAILED=1
                fi
              fi
            fi
          done <<< "$COMMITS"

          if [[ $FAILED -eq 1 ]]; then
            echo "::error::Some commit messages don't follow the convention. See AGENTS.md for format."
            exit 1
          fi

  validate-no-secrets:
    name: Check for Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Scan for Secrets
        run: |
          echo "Scanning for potential secrets..."

          # Patterns to check
          PATTERNS=(
            "AKIA[0-9A-Z]{16}"  # AWS Access Key
            "sk-[a-zA-Z0-9]{48}"  # OpenAI API Key
            "sk-ant-[a-zA-Z0-9-]+"  # Anthropic API Key
            "ghp_[a-zA-Z0-9]{36}"  # GitHub Personal Access Token
            "github_pat_[a-zA-Z0-9_]{82}"  # GitHub PAT (new format)
            "-----BEGIN (RSA |DSA |EC |OPENSSH )?PRIVATE KEY-----"  # Private Keys
            "password\s*[=:]\s*['\"][^'\"]+['\"]"  # Password assignments
            "api[_-]?key\s*[=:]\s*['\"][^'\"]+['\"]"  # API key assignments
          )

          FOUND=0
          for pattern in "${PATTERNS[@]}"; do
            if grep -rE "$pattern" --include="*.js" --include="*.ts" --include="*.py" --include="*.json" --include="*.yml" --include="*.yaml" --include="*.env*" . 2>/dev/null | grep -v node_modules | grep -v ".git"; then
              echo "::error::Potential secret found matching pattern: $pattern"
              FOUND=1
            fi
          done

          # Check for .env files with content
          if find . -name ".env*" -type f ! -name ".env.example" ! -name ".env.template" | xargs -I {} sh -c 'test -s "{}"' 2>/dev/null; then
            echo "::warning::Non-empty .env file found. Ensure no real secrets are committed."
          fi

          if [[ $FOUND -eq 1 ]]; then
            echo "::error::Potential secrets detected! Please remove before merging."
            exit 1
          fi

          echo "No secrets detected."

  validate-files:
    name: Validate Changed Files
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Check File Changes
        run: |
          echo "Checking changed files..."

          # Get changed files
          CHANGED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD)
          echo "Changed files:"
          echo "$CHANGED"

          # Check for potentially dangerous file changes
          DANGEROUS_PATTERNS=(
            ".github/workflows/.*"  # Workflow changes need review
            "package-lock.json"     # Lock file changes
            "yarn.lock"             # Lock file changes
          )

          for pattern in "${DANGEROUS_PATTERNS[@]}"; do
            if echo "$CHANGED" | grep -E "$pattern"; then
              echo "::notice::Sensitive file changed: $pattern - Please review carefully"
            fi
          done

          # Ensure config files are valid JSON
          for file in $(echo "$CHANGED" | grep "\.json$"); do
            if [[ -f "$file" ]]; then
              if ! python3 -m json.tool "$file" > /dev/null 2>&1; then
                echo "::error::Invalid JSON in $file"
                exit 1
              fi
            fi
          done

          echo "File validation passed."

  verify-hashes:
    name: Verify Content Hashes
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'requires-hash')
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify Hashes
        run: |
          echo "Verifying content hashes..."

          # Check if hash utility exists
          if [[ -f "utils/hash.js" ]]; then
            # Create verification script
            cat > verify-hashes.mjs << 'EOF'
          import { SHA256 } from './utils/hash.js';
          import { readFileSync, existsSync } from 'fs';

          const HASH_FILE = '.content-hashes.json';

          if (!existsSync(HASH_FILE)) {
            console.log('No hash file found, skipping verification');
            process.exit(0);
          }

          const hashes = JSON.parse(readFileSync(HASH_FILE, 'utf8'));
          let failed = false;

          for (const [file, expectedHash] of Object.entries(hashes)) {
            if (existsSync(file)) {
              const content = readFileSync(file, 'utf8');
              const actualHash = await SHA256.hash(content);

              if (actualHash !== expectedHash) {
                console.error(`Hash mismatch for ${file}`);
                console.error(`  Expected: ${expectedHash}`);
                console.error(`  Actual:   ${actualHash}`);
                failed = true;
              } else {
                console.log(`Hash verified: ${file}`);
              }
            }
          }

          process.exit(failed ? 1 : 0);
          EOF

            node verify-hashes.mjs
          else
            echo "Hash utility not found, skipping"
          fi

  pr-summary:
    name: Generate PR Summary
    runs-on: ubuntu-latest
    needs: [validate-branch, validate-commits, validate-no-secrets, validate-files]
    if: always()
    steps:
      - name: Create Summary
        uses: actions/github-script@v7
        with:
          script: |
            const branch = context.payload.pull_request.head.ref;
            const isAgent = branch.startsWith('claude/');

            const checks = {
              'Branch Name': '${{ needs.validate-branch.result }}',
              'Commit Messages': '${{ needs.validate-commits.result }}',
              'Secrets Scan': '${{ needs.validate-no-secrets.result }}',
              'File Validation': '${{ needs.validate-files.result }}'
            };

            let summary = '## PR Validation Summary\n\n';
            summary += `| Check | Status |\n|-------|--------|\n`;

            let allPassed = true;
            for (const [check, result] of Object.entries(checks)) {
              const icon = result === 'success' ? 'âœ…' : result === 'skipped' ? 'â­ï¸' : 'âŒ';
              summary += `| ${check} | ${icon} ${result} |\n`;
              if (result === 'failure') allPassed = false;
            }

            summary += `\n---\n`;
            summary += `**Branch Type:** ${isAgent ? 'ðŸ¤– Agent' : 'ðŸ‘¤ Human'}\n`;
            summary += `**Branch:** \`${branch}\`\n`;

            if (!allPassed) {
              summary += `\nâš ï¸ **Some checks failed.** Please review the errors above.\n`;
              summary += `\nFor agent branches, see [AGENTS.md](../blob/main/AGENTS.md) for guidelines.\n`;
            }

            // Post comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: summary
            });

  final-status:
    name: Final Validation Status
    runs-on: ubuntu-latest
    needs: [validate-branch, validate-commits, validate-no-secrets, validate-files]
    if: always()
    steps:
      - name: Check All Results
        run: |
          if [[ "${{ needs.validate-branch.result }}" == "failure" ]] || \
             [[ "${{ needs.validate-commits.result }}" == "failure" ]] || \
             [[ "${{ needs.validate-no-secrets.result }}" == "failure" ]] || \
             [[ "${{ needs.validate-files.result }}" == "failure" ]]; then
            echo "::error::One or more validation checks failed"
            exit 1
          fi
          echo "All validation checks passed!"
